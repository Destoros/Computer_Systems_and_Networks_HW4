Team member: Harald Stiegler, 9330054

Report Assignment 4: Pitfalls, etc.

Task 1
======
When running my home-made C code for reading the temperature via one-wire
in a terminal window on the Pi, everything seems to work fine, except that the Pi hangs ;-) Temperature values
are still printed to the terminal window continuously, but no further input is accepted any more. Pi is frozen. Ignoring any input happens already
at the time of starting the program (although output in terminal window still goes on).
When I change the code from an infinite temperature reading loop to a single temperature read, the program exits normally and
returns even to the terminal window. But the Pi is frozen again and no further input is accepted. 
According to discussion with similar problem in https://github.com/raspberrypi/linux/issues/2550, a possible workaround could be usage of an older kernel, I tried this one:
http://downloads.raspberrypi.org/raspbian/images/raspbian-2015-02-02/
Problem still persists. Other ideas: Use reverse operation of mmap or close /dev/mem filehandle at program exit. But: Pi freezes
already when program starts, therefore cleanup at program end will not help (most probably).
Therefore:
According to Konrad's slack entry I am allowed to use a Python script, which uses the raspberry's own one-wire implementation contained
in the raspberry image/standard package to read a temperature's sensor value.
Python script from: https://st-page.de/2018/01/20/tutorial-raspberry-pi-temperaturmessung-mit-ds18b20/

Task 2
======
swagger:
Using flask/python combination because Python script has been proposed by Konrad to read out temperature sensor's value if 
own code doesn not run on Raspbian (this applies to me). Flask seems to be the only "python" server supported by swagger (good experience by other students too). Apache supports python too, but I do not know how well apache and swagger fit together (and swagger delivers a whole server anyway). 
Going through tutorial
https://projects.raspberrypi.org/en/projects/python-web-server-with-flask/2
Now I do the statements in Readme.md delivered by swagger when generating a flask/python server.
Calling localhost:8080/v2/getTemperature in browser
(Call temperature reading python script in swagger_server/controllers/temperature_controller.py)
As my C code triggers the Pi to freeze, I do not think about a Python - C interface for calling my own temeprature sensor reading program. 
File python-flask-server\swagger_server\swagger\swagger.yaml has been generated by swagger/Editor.
Start server on Pi by "python3 -m swagger_server"

Task 3
======
Task description "...create another server..." may be interpreted in different ways. In order to minimize effort, I look for an existing CoAP server and extend this one by an additional observable "temperature" resource.
txThings seems to be good choice, tutorial available at https://www.win.tue.nl/~lrahman/iot_2016/tutorial/txThings_2016.pdf
BUT: How to integrate sensor code? No tutorial found, let's try aiocoap (seems to have a better tutorial) 
Starting at https://aiocoap.readthedocs.io/en/latest/installation.html
"Normal/default" aiocoap installation fails at first, developer version is required.
I only need to update aiocoap/server.py (copy TimeResource and rename it to TemperatureResource, plus integrate python code to read temperature)
Pros/Cons of CoAP from my point of view: It is the first time I came in contact with CoAP, I have no experience, but the more I understand, the more I like it.
Start server in directory aiocoap by "./server.py"

Task 4
======
Task description "...Select one messaging protocol...and IMPLEMENT it..": Really? Implement whole protocol from scratch? I prefer again to use an existing protocol implementation from the web and extend this one by delivering temperature sensor values.
Found https://tutorials-raspberrypi.com/raspberry-pi-mqtt-broker-client-wireless-communication/
Using mosquitto-server and paho, exactly as described in tutorial above. Works fine.
Only publisher needs to be written (file Task4/mqtt_publisher.py).
Start "subscriber" by "mosquitto_sub -h localhost -v -t test_channel"

Reasons for MQTT: To be honest: It was the first in the list and I found a working tutorial. Adaptation of sample file to my requirements was simple and worked immedately. If not, I would have gone to another protocol or another implementation of MQTT. RabbitMQ (AMQP implementation) seems to work fine too. As in the task description no further requirements are specified, specific properties of these protocols will not be exploited (e.g. point to point in AMQP versus publish/subscribe in MQTT). Therefore decision is a bit arbitrary.




